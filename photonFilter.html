<!DOCTYPE html>
<html>
 <!-- Simulation of photons being filtered -->
 <!-- Created by Tristan Miller, May 2016 -->
 <!-- Download and then open in your browser. A bit slow in Firefox though! -->  
<head>
<meta charset="utf-8">
<title>Photon Filtering</title>
<style>

//this CSS is terrible and I feel bad about it
canvas {
    border: 1px #CCC solid;
}

#ui {
	width: 70%;
	position: absolute;
	top: 90%;
}

input.comptrol {
position:relative;
left:30%;
width:50%;
}

#experiment{
	position:absolute;
	top:0%;
	height:80%;
	width: 100%;
}

#screen {
position: absolute;
top:0%;
height:80%;
}

#spectrum {

margin: auto;
    display: block;
}

#filSpec {
margin: auto;
    display: block;
}

.specWrapper {
position:absolute;
right:0px;
width: 550px;
height: 400px;
background-color: #999999;
}

#filter {
 right:0px;
 top: 420px;
 background-color: #FF9933;
}

#status{
	position:relative;
	top:80%;
	width: 100%;
}



label {
	position:absolute;
	width:30%;
}

button {
margin:10px;
}

</style>
</head>

<body>




<div id = "experiment">

<div id="graphics">
<canvas id="screen" height="600" width="600"></canvas>
</div>
<h2 id="status">0 | 0</h2>
<div id = "ui" onmousedown="false">
	<button type="button" id="lamp" onclick="lampToggle()">Turn lamp off</button>
	<button type="button" id="impacts" onclick="impactToggle()">Highlight absorptions</button>
	<button type="button" id="playPause" onclick="buttonChange()">Pause</button>
	<button type="button" id="reset" onclick="resetScreen()">Reset</button>
<br>
	<label for="brightnessS" >Brightness (average photons per frame)</label>
	<input type="range" class="comptrol" id="brightnessS"  min="0" max ="100" step="0.1" value="10" onInput="inputUpdate(value, min, max, id, 'brightnessT')" >
	<input type="text" class="comptrol"id="brightnessT" min="0" max="100"  value="10" onInput="inputUpdate(value, min, max, id, 'brightnessS')">
	<br>
	<label for="transS" >Probability for transmission</label>
	<input type="range" id="transS" class="comptrol" min = "0" max = "1" step = "0.001" value="0.20" onInput="inputUpdate(value, min,max, id, 'transT')">
	<input type="text" id="transT" class="comptrol" min = "0" max = "1" step = "any" value="0.20" onInput="inputUpdate(value, min,max, id, 'transS')">
	<br>	
	<label for="fadeS" >Fade rate</label>
	<input type="range" id="fadeS" class="comptrol" min = "0" max = "100" step = "0.1" value="25" onInput="inputUpdate(value, min, max,id, 'fadeT')">
	<input type="text" id="fadeT" class="comptrol" min = "0" max = "100" value = "25" onInput="inputUpdate(value, min, max, id, 'fadeS')">
	<br>	

	
	</div>
</div>
<div id="source" class="specWrapper">
<canvas id="spectrum" width="530" height="350"></canvas>
</div>
<div id="filter" class="specWrapper">
<canvas id="filSpec" width="530" height="350"></canvas>
</div>

<script>
"use strict";
var pause = false;
	
	var mouseX = 0;
	var mouseY = 0;
	
	var nIn = 0;
	var nOut = 0;
	
	var title = document.querySelector("#theTitle");
	document.querySelector("#screen").width = document.querySelector("#screen").height;
	var mainCanvas = document.querySelector("#screen");
	var mainContext = mainCanvas.getContext("2d");
	var source = document.querySelector('#source');
	var specCanvas = document.querySelector("#spectrum");
	var specContext = specCanvas.getContext("2d");
	
specCanvas.style.cursor = "crosshair";
	
	var specDrawBounds = [0.15*specCanvas.width, 0.95*specCanvas.width, 0.20*specCanvas.height, 0.85*specCanvas.height];
	for(var i = 0; i<specDrawBounds.length; i++){
	specDrawBounds[i] = Math.round(specDrawBounds[i]);
	}
	
var mouseStillDown = false;

specCanvas.addEventListener('mousemove', function(event){
		mouseX = event.pageX - specCanvas.offsetLeft - source.offsetLeft;
		mouseY = specCanvas.height - (event.pageY - specCanvas.offsetTop - source.offsetTop);
		if(mouseStillDown){
			var thisChannel = constrain(Math.floor((mouseX - specDrawBounds[0])/channelWidth),0,spectrumChannels.length - 1);
			changeSpectrum(spectrumChannels,thisChannel);
		}
	});
	
specCanvas.addEventListener('mousedown', function(event){
	var thisChannel = constrain(Math.floor((mouseX - specDrawBounds[0])/channelWidth),0,spectrumChannels.length - 1);
	changeSpectrum(spectrumChannels,thisChannel);
	mouseStillDown = true;
	
	});
	
specCanvas.addEventListener('mouseup', function(event){
	mouseStillDown = false;

	});
	
specCanvas.addEventListener('mouseout', function(event){
	mouseStillDown = false;
	});

	
	var canvasWidth = mainCanvas.width;
	var canvasHeight = mainCanvas.height;
	var specWidth = specCanvas.width;
	var specHeight = specCanvas.height;
	


	var requestAnimationFrame = window.requestAnimationFrame || 
                            window.mozRequestAnimationFrame || 
                            window.webkitRequestAnimationFrame || 
                            window.msRequestAnimationFrame;
							
							

var channelWidth = 5;
var channels = Math.round((specDrawBounds[1] - specDrawBounds[0])/channelWidth);
	var photons = new Array();
	var filters = new Array();
	var impacts = new Array();
	var spectrumChannels = new Array();
	var spectrumCDF = new Array();
	
	for(var i = 0; i < channels + 1; i++){
		spectrumChannels.push(Math.round(specHeight/2));
		spectrumCDF = createCDF(normaliseSpectrum(spectrumChannels));
	}
	
	var photonVel = 2; //pixels per frame. This is the speed of light!
	
	var newFilter = new Filter(canvasWidth/2, canvasHeight/2, 200, 400, 0.00001, photonVel);
	filters.push(newFilter);

	var minVisEn = 1.8; //eV
	var maxVisEn = 3.1; //eV
	
	var lampOn = true;
	var impactsOn = false;
	
	var testFilter = new Spectrum("#filSpec", "#filter", 5);
	var testSource = new Spectrum("#spectrum", "#source", 5);

resetScreen();
drawPhotons();

function drawPhotons() {
	drawSpectra();
	var status = document.getElementById('status');
	status.innerHTML = nIn+ " photons in | " + nOut + " photons out";

	var brightness = getInputValue("brightnessS");
	var trans = getInputValue("transS");
	var fadeRate = getInputValue("fadeS");
	
  	mainContext.fillStyle = "rgba(0,0,0," + fadeRate/100 + ")";
  	mainContext.fillRect(0, 0, canvasWidth, canvasHeight);
	

	
	updatePhotons(photons);
	updateImpacts(impacts);

	removeObjects(photons);
	removeObjects(impacts);

	if(brightness > 0 && lampOn){
 	   for (var i = 0; i < 5; i++) {
		   if(Math.random() <= brightness/100){
			   createPhoton(photons);
		   }
		   
	   }
   }
   
for(var i = 0; i < filters.length; i++){
	var thisFilter = filters[i];
	thisFilter.t = trans;
	thisFilter.update();
	thisFilter.render();
}	
   

   
   if(!pause){
	   requestAnimationFrame(drawPhotons);
   } else {
	mainContext.fillStyle = "rgba(100,100,255,0.3)";
	mainContext.fillRect(canvasWidth/2 - 150, canvasHeight/2 - 75, 300, 100);
	
    mainContext.fillStyle = "rgb(255,255,255)";
    mainContext.font="80px Helvetica";
    mainContext.textAlign = "center";
    mainContext.fillText("Paused!",canvasWidth/2 ,canvasHeight/2 );
   }
}

function drawSpectra(){
	testFilter.render();
	testSource.render();
	
	/*specContext.fillStyle = "rgba(0,0,0,1)";
	specContext.fillRect(0,0, specWidth, specHeight);
	specContext.fillStyle = "rgba(255,255,0,0.7)";
    specContext.font="80px Helvetica";
    specContext.textAlign = "center";
    specContext.fillText(mouseX + ", " + mouseY,specWidth/2 ,specHeight/2 );

	for(var i = 0; i < spectrumChannels.length; i++){
		var col = Math.round(map_range(i, 0, spectrumChannels.length, 0, 265))
		specContext.fillStyle = "hsla(" + col + ",100%,50%,1)"	;
		//specContext.fillRect(i*channelWidth, specHeight - spectrumChannels[i], channelWidth,channelWidth);

			
			specContext.strokeStyle = specContext.fillStyle;
			//specContext.stroke();
			
			
			specContext.strokeRect((i+1)*channelWidth + specDrawBounds[0], specDrawBounds[3],-1*channelWidth, -1*spectrumChannels[i]);
			
			
		
	}*/
	
	if(pause){
	requestAnimationFrame(drawSpectra);
	}
}


function changeSpectrum(s,c){
	s[c] = constrain(mouseY - (specCanvas.height - specDrawBounds[3]),0,(specDrawBounds[3] - specDrawBounds[2]));
	
	if(c > 1 && c < s.length - 2){
		s[c + 1] = Math.round(0.5*s[c]+ 0.5*s[c + 2]);
		s[c - 1] = Math.round(0.5*s[c]+ 0.5*s[c - 2]);
	}

	spectrumCDF = new Array();
	spectrumCDF = createCDF(normaliseSpectrum(s));

}


function constrain (val, min, max) {
	return(Math.min(Math.max(val, min), max));
}

function map_range (val, oldLow, oldHigh, newLow, newHigh){
return(((oldLow + val)/(oldHigh - oldLow))*(newHigh - newLow) + newLow);

}

function inputUpdate(val, min, max, idThis, idThat) {
	val = constrain(val,min,max);
	document.querySelector("#"+idThis).value = val;
	document.querySelector("#"+idThat).value = val;
}
	
function getInputValue(id) {
    return(document.getElementById(id).value);
}

function buttonChange(){
	var button = document.querySelector('#playPause');
	if(pause){
		button.textContent="Pause";
		requestAnimationFrame(drawPhotons);
	} else {
		button.textContent="Play";
		

			
	}
	pause = !pause;
}

function lampToggle(){
	var button = document.querySelector('#lamp');
	if(lampOn){
		button.textContent="Turn lamp on";
	} else {
		button.textContent="Turn lamp off";	
	}
	lampOn = !lampOn;
}

function impactToggle(){
	var button = document.querySelector('#impacts');
	if(!impactsOn){
		button.textContent="Stop highlighting absorptions";
	} else {
		button.textContent="Highlight absorptions";	
	}
	impactsOn = !impactsOn;
}

function resetScreen(){
	mainContext.fillStyle = "rgba(0,0,0,1)";
	mainContext.fillRect(0, 0, canvasWidth, canvasHeight);
	photons = new Array();
	nIn = 0;
	nOut = 0;
	
	requestAnimationFrame(drawPhotons);
}

function createPhoton(p){
	var chan = testSource.sampleCDF(testSource.spectrumCDF);
	var chanMin = map_range(chan,0, spectrumCDF.length, minVisEn, maxVisEn);
	var chanMax = chanMin + (maxVisEn-minVisEn)/(testSource.spectrumCDF.length);
		
		var en = map_range(Math.random(),0,1,chanMin,chanMax);
		var newPhoton = new Photon(map_range(Math.random(),0,1,0,photonVel), map_range(Math.random(),0,1,0.3*canvasHeight,0.7*canvasHeight), photonVel, 0, en);
		p.push(newPhoton);
		nIn++;

}
function updatePhotons(p){
	for(var i = 0; i < p.length; i++) {
		var thisPhoton = p[i];
		thisPhoton.update();
		
		for(var j = 0; j < filters.length; j++){
			var thisFilter = filters[j];
			if(thisPhoton.posX > thisFilter.posX - thisFilter.w/2 && thisPhoton.posX < thisFilter.posX + thisFilter.w/2 && thisPhoton.posY > thisFilter.posY - thisFilter.h/2 && thisPhoton.posY < thisFilter.posY + thisFilter.h/2){
				if(Math.random()>thisFilter.coeff){
					thisPhoton.alive = false;
					if(impactsOn){
						var newImpact = new Impact(thisPhoton.posX, thisPhoton.posY, thisPhoton.fillStyle);
						impacts.push(newImpact);
					}
				}	
			}
		}
		
		if(thisPhoton.posX > canvasWidth || thisPhoton.posX < 0 || thisPhoton.posY > canvasHeight || thisPhoton.posY < 0){
			thisPhoton.alive = false;
			nOut++;
		}
		
		thisPhoton.render();	
	}
}

function updateImpacts(p){
	for(var i = 0; i < p.length; i++) {
		var thisImpact = p[i];
		thisImpact.update();
		thisImpact.render();
	}
}

function removeObjects(p){
for(var i = p.length - 1; i >= 0; i--) {
		var thisPhoton = p[i];
		if(!thisPhoton.alive){
		p.splice(i,1);
		}	
	}
}

function normaliseSpectrum(s){
	var S = 0;
	var N = new Array();
	for(var i = 0; i < s.length; i++){
		S = S + s[i];
	}
	for(var i = 0; i < s.length; i++){
		if(S == 0){
			N.push(1/s.length);
		} else {
			N.push(s[i]/S);
		}
	}
	return(N);
}

function createCDF(N){
	var CDF = new Array();
	CDF.push(N[0]);
	for(var i = 1; i < N.length; i++){
		CDF.push(CDF[i-1] + N[i]);
	}
	
	return(CDF);
	
}

function sampleFromCDF(CDF){
	var sample = Math.random();
	for(var i = 0; i < CDF.length; i++){
		if(sample < CDF[i]){
			return(i);
			break;
		}
	
	}
}

//Object definitions							
							
function Photon(posX, posY, velX, velY, energy) {
	
	this.radius = 2;
	this.posX = posX;
	this.posY = posY;
	this.velX = velX;
	this.velY = velY;
	this.energy = energy;
	this.alive = true;
	
	energy = constrain(energy, minVisEn, maxVisEn);
	this.col = Math.round(map_range(energy, minVisEn, maxVisEn, 0, 265));
	

	this.fillStyle = "hsla(" + this.col + ",100%,50%,1)";

	
	this.update = function(){
	
		this.posX = this.posX + this.velX;
		this.posY = this.posY + this.velY;	
		
	}
	
	this.render = function(){

		
	
		mainContext.fillStyle = this.fillStyle;
		mainContext.fillRect(this.posX - this.radius, this.posY - this.radius, 2*this.radius, 2*this.radius);
		
		//mainContext.fillStyle = "rgba(255,255,255,0.9)"
		//mainContext.fillRect(this.posX - 0.2*this.radius, this.posY - 0.2*this.radius, 0.4*this.radius, 0.4*this.radius);
		
	}

}

function Filter(posX, posY, w, h, t, vel){
	this.posX = posX;
	this.posY = posY;
	this.w = w;
	this.h = h;
	this.t = t;
	this.vel = vel;
	
	this.strokeStyle = "rgba(255,255,0,1)"; //this will later be dependent on its spectral properties?
	
	this.update = function(){
		this.coeff = Math.pow(this.t, this.vel/this.w);
	}
	
	this.render = function(){
		mainContext.strokeStyle = this.strokeStyle;
		mainContext.strokeRect(this.posX - w/2, this.posY - h/2,w,h);

	}
	
}




function Impact(posX, posY, col){
	this.posX = posX;
	this.posY = posY;
	this.col = col;
	
	
	
	this.radius = 5;
	this.alive = true;
	this.counter = 0;
	
	this.update = function(){
		this.counter++;
		this.radius = this.radius*1.1;
		if(this.counter > 6){
			this.alive = false;
		}
		
	}

	this.render = function(){
		mainContext.strokeStyle = this.col;
		mainContext.strokeRect(this.posX - this.radius, this.posY - this.radius, this.radius*2,this.radius*2);

	}
}

////////////////////
function Optics(canvas) {
	var thisSpectrum = new Spectrum(canvas);
}


function Spectrum(cnv, div, cWidth) {


	function updateSpectrum(s,c){
		s[c] = constrain(mY - (canvas.height - drawBounds[3]),0,(drawBounds[3] - drawBounds[2]));
	
		if(c > 1 && c < s.length - 2){
			s[c + 1] = Math.round(0.5*s[c]+ 0.5*s[c + 2]);
			s[c - 1] = Math.round(0.5*s[c]+ 0.5*s[c - 2]);
		}
		spectrumCDF = new Array();
		spectrumCDF = makeCDF(normSpectrum(s));

	}	

	function normSpectrum(s){
		var S = 0;
		var N = new Array();
		for(var i = 0; i < s.length; i++){
			S = S + s[i];
		}
		for(var i = 0; i < s.length; i++){
			if(S == 0){
				N.push(1/s.length);
			} else {
				N.push(s[i]/S);
			}
		}
		return(N);
	}

	function makeCDF(N){
		var CDF = new Array();
		CDF.push(N[0]);
		for(var i = 1; i < N.length; i++){
			CDF.push(CDF[i-1] + N[i]);
		}
	
		return(CDF);	
	}
	
	function sampleCDF(CDF){
		var sample = Math.random();
		for(var i = 0; i < CDF.length; i++){
			if(sample < CDF[i]){
				return(i);
				break;
			}
		}
	}
	
	var encDiv = document.querySelector(div);
	console.log(encDiv.offsetLeft);

	var canvas = document.querySelector(cnv);
	console.log(canvas.offsetLeft);

	var ctx = canvas.getContext("2d");
	
	canvas.style.cursor = "crosshair";
	var drawBounds = [0.15*canvas.width, 0.95*canvas.width, 0.20*canvas.height, 0.85*canvas.height];
	console.log(drawBounds);
	var spectrumCDF = new Array();
	var mStillDown = false;
	var chanWidth = cWidth;
	var channels = Math.round((drawBounds[1] - drawBounds[0])/chanWidth);
	var channelArray = new Array();
	
	var mX = 0;
	var mY = 0;
	
	for(var i = 0; i < drawBounds.length; i++){
		drawBounds[i] = Math.round(drawBounds[i]);
	}
	

	
	for(var i = 0; i < channels + 1; i++){
		channelArray.push(Math.round(canvas.height/2));
		spectrumCDF = makeCDF(normSpectrum(channelArray));
	}
	

	
	canvas.addEventListener('mousemove', function(event){
		mX = event.pageX - canvas.offsetLeft - encDiv.offsetLeft;
		mY = canvas.height - (event.pageY - canvas.offsetTop - encDiv.offsetTop); 
		if(mStillDown){
			var thisChannel = constrain(Math.floor((mX - drawBounds[0])/chanWidth),0,channelArray.length - 1);
			updateSpectrum(channelArray,thisChannel);
		}
	});
	
	canvas.addEventListener('mousedown', function(event){
		var thisChannel = constrain(Math.floor((mX - drawBounds[0])/chanWidth),0,channelArray.length - 1);
		updateSpectrum(channelArray,thisChannel);
		mStillDown = true;
	});
	
	canvas.addEventListener('mouseup', function(event){
		mStillDown = false;
	});
	
	canvas.addEventListener('mouseout', function(event){
		mStillDown = false;
	});

	

	
	
this.render = function(){
   
		ctx.fillStyle = "rgba(0,0,0,1)";
		ctx.fillRect(0,0, canvas.width, canvas.height);
		ctx.fillStyle = "rgba(255,255,0,0.7)";
		ctx.font="80px Helvetica";
		ctx.textAlign = "center";
		ctx.fillText(mX + ", " + mY, canvas.width/2 ,canvas.height/2 );

		for(var i = 0; i < channelArray.length; i++){
			var col = Math.round(map_range(i, 0, channelArray.length, 0, 265));
			ctx.fillStyle = "hsla(" + col + ",100%,50%,1)"	;
			ctx.strokeStyle = ctx.fillStyle;
			ctx.strokeRect((i+1)*chanWidth + drawBounds[0], drawBounds[3],-1*chanWidth, -1*channelArray[i]);	
		
		}
	
	}
}



</script>
</body>
</html>
